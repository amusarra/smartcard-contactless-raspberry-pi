{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Informazioni sulla Guida","text":"<p>Antonio Musarra, Raspberry Pi e Smart Card Mifare Classic 1K - Guida pratica per realizzare un sistema di autenticazione con smart card contactless su Raspberry Pi</p> <p>Il progetto di esempio realizzato per quest'opera \u00e8 disponibile sul repositoy GitHub all'indirizzo https://github.com/amusarra/smartcard-contactless-raspberry-pi</p> <p>Quest'opera \u00e8 stata realizzata usando l'approccio doc-as-code e il testo \u00e8 stato scritto in formato Markdown.</p> <p>Nel caso di errori, segnalazioni o suggerimenti, si prega di aprire una issue o discussione sul repository GitHub.</p> <p>Progetto Smart Card Contactless Raspberry Pi</p> <ol> <li>Apertura issue https://github.com/amusarra/smartcard-contactless-raspberry-pi/issues</li> <li>Apertura discussione https://github.com/amusarra/smartcard-contactless-raspberry-pi/discussions</li> </ol> <p>Nell'ambito del social coding e del contributo alla comunit\u00e0, \u00e8 possibile contribuire al progetto con una pull request per migliorare questa guida e il progetto di esempio.</p> <p>Note sul Copyright Tutti i diritti d\u2019autore e connessi sulla presente opera appartengono all\u2019autore Antonio Musarra. Per volont\u00e0 dell\u2019autore quest\u2019opera \u00e8 rilasciata nei termini della licenza Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International il cui testo integrale \u00e8 disponibile alla pagina web https://creativecommons.org/licenses/by-nc-sa/4.0/deed.it</p> <p>Tutti i marchi riportati appartengo ai legittimi proprietari; marchi di terzi, nomi di prodotti, nomi commerciali, nomi corporativi e societ\u00e0 citati possono essere marchi di propriet\u00e0 dei rispettivi titolari o marchi registrati d\u2019altre societ\u00e0 e sono stati utilizzati a puro scopo esplicativo e a beneficio del possessore, senza alcun fine di violazione dei diritti di copyright vigenti.</p>"},{"location":"guida/atr/","title":"Cos\u2019\u00e8 l\u2019Answer to reset o ATR","text":"<p>La prima risposta di una Smart Card inserita in un lettore si chiama ATR (Answer to reset). Lo scopo dell'ATR \u00e8 descrivere i parametri di comunicazione supportati, la natura e lo stato della carta. L'ottenimento di un ATR viene spesso utilizzato come prima indicazione che questa sia operativa, e il suo contenuto viene esaminato come prima prova che sia del tipo appropriato per un determinato utilizzo. Il lettore di Smart Card, il driver del lettore e il sistema operativo utilizzeranno questi parametri per stabilire una comunicazione con la scheda.</p> <p>L'ATR \u00e8 descritto dallo standard ISO/IEC 7816-3. I primi byte dell'ATR descrivono i parametri elettrici, seguiti da byte che descrivono le interfacce di comunicazione disponibili e i rispettivi parametri. Questi byte di interfaccia sono quindi seguiti da byte storici che non sono standardizzati e sono utili per trasmettere informazioni proprietarie come il tipo di scheda, la versione del software integrato o lo stato della scheda. Infine questi byte storici sono eventualmente seguiti da un byte di checksum.</p> <p>Potremmo riassumere che l'ATR contiene \"un sacco di dati\" che ci dicono vita morte e miracoli della Smart Card. Per esempio, scopriamo di pi\u00f9 sull'ATR <code>3B 8F 80 01 80 4F 0C A0 00 00 03 06 03 00 01 00 00 00 00 6A</code>\u00a0 utilizzando il tool Smart card ATR parsing sviluppato da Ludovic Rousseau. La figura a seguire mostra le informazioni estratte alcune delle quali:</p> <ul> <li>tipo di Smart Card e in questo caso si tratta della MIFARE Classic 1K;</li> <li>produttore della Smart Card e in questo caso NXP;</li> <li>standard tecnologici;</li> <li>protocolli di comunicazione e in questo caso T=0 (orientato al byte,   che costituisce l'unit\u00e0 minima di informazione scambiata) e T=1   (orientato al blocco di byte, grazie al quale la velocit\u00e0 di accesso \u00e8   maggiore), protocollo solitamente utilizzato di default quando   disponibile e supportato anche dal lettore.</li> </ul> <p> Figura 11 - Dettagli estratti sull'ATR della Smart Card MIFARE Classic 1K</p> <p>Ludovic Rousseau ha fatto un ottimo lavoro tracciando dal 2002 un gran numero di ATR costruendo un vero e proprio database. Cos\u00ec facendo \u00e8 possibile identificare una Smart Card dato il suo ATR. All'interno della lista sono presenti anche le \"nostrane Smart Card\" come la TS-CNS (Tessera Sanitaria - Carta Nazionale Servizi) e CIE (Carta d'Identit\u00e0 Elettronica). \u00c8 possibile utilizzare il comando <code>pcsc_scan</code> per ottenere informazioni di dettaglio sulla Smart Card, le stesse illustrate in figura 11. La figura 12 mostra l'output del comando menzionato da cui \u00e8 possibile dedurre che la Smart Card analizzata \u00e8 una CIE.</p> <p> Figura 12 - Esempio di output del comando pcsc_scan che mostra le informazioni estratte dalla Smart Card, in questo caso CIE</p>"},{"location":"guida/conclusioni/","title":"Conclusioni","text":"<p>Ringrazio tutti voi per essere arrivati \u201cincolumi\u201d alla fine di questo lungo percorso sperando di non essere stato noioso e di essere riuscito nell\u2019intento di rendere interessanti gli argomenti trattati oltre che a spingere la vostra curiosit\u00e0 in avanti.</p> <p>Potrei lasciarvi un compito per casa: come aprire la porta di casa utilizzando la propria CIE o TS-CNS.</p> <p>Mi sarebbe piaciuto approfondire maggiormente alcuni degli argomenti trattati, come per esempio il framework Pyscard e alcune sezioni del codice Python sviluppato. Nell\u2019attesa di pubblicare altri articoli di approfondimento, vi chiedo di scrivere le vostre impressioni, esperienze o altro di cui vorreste qualche approfondimento utilizzando i commenti all\u2019articolo oppure condividendo attraverso i classici canali social.</p> <p>Sempre nell'ottica Open Source, il progetto Smart Card Contactless Raspberry Pi pubblicato sul mio repository GitHub, contiene all'interno della directory docs i seguenti elementi:</p> <ul> <li>il file diagrams.drawio contenente diagrammi e tabelle. File che   potete aprire con Draw.io</li> <li>il file SCH_Smart_Card_Contactless_Raspberry_Pi_2022-03-11.json dello   schema elettrico che potete aprire con   EasyEDA</li> <li>i file UML *.puml di PlantUML che contengono i sequence diagram</li> </ul>"},{"location":"guida/deploy_test_software_on_rpi/","title":"Installazione e test","text":"<p>Ci siamo! \u00c8 arrivato il momento d'installare il progetto software sul Raspberry Pi e verificare che tutto funzioni cos\u00ec per com'\u00e8 stato ideato. Il deployment diagram della figura a seguire mostra tutti i componenti del nostro sistema di accesso.</p> <p> Figura 22 - Deployment diagram del sistema di accesso via Smart Card Contactless su Raspberry Pi</p> <p>Assumiamo a questo punto che tutti i requisiti software indicati in precedenza siano tutti soddisfatti (fare riferimento a 6. Requisiti Software). Per installare il progetto software sul Raspberry Pi occorre seguire i seguenti passi:</p> <ol> <li>accedere in ssh alla Raspberry Pi;</li> <li>decidere una locazione dove installare il progetto software. Non ci     sono restrizioni; nel mio caso ho preferito usare la home del mio     account;</li> <li>eseguire il clone del repository del progetto;</li> <li>eseguire l'installazione delle dipendenze Python.</li> </ol> <p>Per ambienti di sviluppo o test \u00e8 possibile pensare di fare ricorso alla creazione di quella che viene definita nel mondo Python, Virtual Environments.</p> <p><pre><code># Accesso al Raspberry Pi via SSH\nssh amusarra@192.168.238.169\n\n# Clone del repository GitHub del progetto\ngit clone https://github.com/amusarra/smartcard-contactless-raspberry-pi.git\n\n# Installazione delle dipendenze Python\ncd smartcard-contactless-raspberry-pi\nmake\n</code></pre> Console 2 - Installazione del progetto software</p> <p>Il comando <code>make</code> non fa altro che procedere con l'installazione delle dipendenze Python specificate sul file requirements.txt utilizzando pip. La figura 23 mostra il processo d'installazione delle dipendenze Python sul Raspberry Pi. Ultimata l'installazione, \u00e8 possibile eseguire il test vero e proprio del software. Prima di eseguire il test occorre accertarsi che dal punto di vista hardware sia tutto regolare controllando tutti i collegamenti (vedi schema elettrico), compreso il collegamento del lettore di Smart Card via USB.</p> <p> Figura 23 - Installazione delle dipendenze Python tramite il comando make</p> <p>Ormai dovremmo sapere quali sono gli entry point da utilizzare, sia quello per il setup della Smart Card, sia quello che avvia il controllo degli accessi. Entrambi gli entry point, quindi gli script Python, devono essere avviati specificando una serie di parametri. Le due tabelle a seguire mostrano i parametri d'input dei due script: <code>setup_smart_card.py</code> e <code>access_via_smart_card.py</code>.</p> <p> Figura 24 - Tabella dei parametri d'input per lo script Python setup_smart_card.py</p> <p> Figura 25 - Tabella dei parametri d'input per lo script Python access_via_smart_card.py</p> <p>La figura 26 mostra un esempio di come si presenta l'help in linea dello script <code>setup_smart_card.py</code> attivato utilizzando l'opzione <code>--help</code> (o <code>-h</code>).</p> <p> Figura 26 - Come si presenta l'help in linea dello script setup_smart_card.py</p> <p>A questo punto siamo davvero pronti. Il primo step \u00e8 la registrazione della Smart Card per il nuovo ospite Mario Rossi il cui documento d'identit\u00e0 ha il numero MU589876XD e al quale assegnamo la stanza numero due.</p> <p>Prima di avviare la registrazione, prendiamo la Smart Card poggiandola sul lettore. Il comando da avviare per la registrazione \u00e8: <code>./setup_smart_card.py -a FFFFFFFFFFFF -i MU589876XD -s --firstname Mario --lastname Rossi -r 2</code></p> <p>Se tutto va per il verso giusto, l'output ottenuto in console dovrebbe essere quello mostrato dalla figura a seguire.</p> <p> Figura 27 - Registrazione Smart Card MIFARE Classic 1K con i dati dell'ospite</p> <p>Dopo la registrazione della Smart Card e la consegna all'ospite, quest'ultimo pu\u00f2 usare la Smart Card per accedere alla propria stanza assegnata in fase di registrazione, che ricordo essere la numero due.</p> <p> Figura 28 - Documento registrato su MongoDB a fronte del processo di registrazione Smart Card</p> <p>Avviamo adesso il programma del controllo degli accessi utilizzando il comando: <code>./access_via_smart_card.py -a FFFFFFFFFFFF</code>. Avviato il programma, questo resta in attesa di leggere la Smart Card. Poggiando la Smart Card registrata poc'anzi, l'ospite dovrebbe riuscire ad accedere alla sua stanza, cos\u00ec come mostra la figura a seguire.</p> <p> Figura 29 - Richiesta di accesso via Smart Card MIFARE Classic 1K</p> <p>L'output mostrato dalla figura 29 evidenzia anche un accesso non riuscito perch\u00e9 in questo caso la Smart Card presentata non \u00e8 registrata sul sistema. Gli screencast a seguire mostrano i due entry point in azione: setup_smart_card.py e access_via_smart_card.py.</p> <p> Screencast 1 - Processo di registrazione Smart Card in azione</p> <p> Screencast 2 - Processo di accesso alla stanza via Smart Card in azione</p> <p>Dopo i due screencast che mostrano il sistema di accesso in azione, possiamo affermare che il nostro lavoro di analisi, progettazione e implementazione sia arrivato al termine, raggiungendo anche l'obiettivo prefissato.</p>"},{"location":"guida/descrizione_scenario/","title":"Descrizione dello scenario","text":"<p>Credo d'intuire quale potrebbe essere il vostro pensiero in questo momento. Che tipo di Sistema di Accesso andremo a realizzare?</p> <p>Vorrei implementare qualcosa che tutti almeno una volta abbiamo usato. Un comunissimo scenario di Sistema di Accesso lo abbiamo vissuto tutti accedendo alla nostra camera di albergo grazie alla Smart Card (o chiave elettronica) consegnata al momento dell'accoglienza. </p> <p>La figura a seguire mostra lo schema hardware della soluzione che andremo a realizzare.</p> <p></p> <p>Figura 1 - Schema hardware della soluzione di accesso (Smart Card icon da https://www.smartcardfocus.com/</p> <p>La MIFARE Classic\u00ae 1K contactless si basa su NXP MF1 IC S50. Questa tipologia di carta \u00e8 una buona scelta per applicazioni classiche come la biglietteria dei trasporti pubblici, servizi di fidelizzazione e pu\u00f2 essere utilizzata anche per molte altre applicazioni come sistemi di apertura porte e simili.</p> <p>Il lettore di Smart Card deve essere conforme a standard indicati nello schema di figura 1. Nel mio caso ho utilizzato il lettore CIE Bit4id miniLector collegato al Raspberry Pi tramite la porta USB. Il nome tecnico del lettore che ho utilizzato \u00e8: BIT4ID miniLector AIR NFC v3.</p> <p>Al Raspberry Pi \u00e8 collegato un modulo di quattro rel\u00e8 gestito tramite le porte GPIO. Nel nostro scenario, i rel\u00e8 rappresentano gli attuatori necessari per aprire le porte dell'hotel dove siamo ospiti.</p> <p>Appurato che il nostro scenario \u00e8 quello di un sistema di accesso per consentire agli ospiti di un hotel di accedere alle proprie stanze attraverso una Smart Card, vediamo quali sono i due processi che portano al raggiungimento di questo obiettivo.</p> <p>La figura 2 illustra il processo semplificato (in notazione BPMN) di ci\u00f2 che accade quando un ospite viene ricevuto dal personale dell'hotel. Dell'intero processo, solo il Service Task (indicato in rosso) sar\u00e0 l'oggetto dell'implementazione del software.</p> <p> Figura 2 - Processo semplificato di accoglienza dell'ospite in hotel.</p> <p>Il processo di figura 3 mostra invece cosa succede quando l'ospite chiede di entrare nella sua camera tramite l'uso della chiave elettronica appoggiandola sul lettore. Dell'intero processo, solo i Service Task (indicati in rosso) saranno oggetto dell'implementazione del software.</p> <p> Figura 3 - Processo di accesso alla stanza</p> <p>Credo che tutti i processi illustrati (in figura 2 e figura 3) in notazione BPMN siano abbastanza esplicativi da non richiedere ulteriori approfondimenti. I Service Task sono gli elementi che saranno oggetto di nostro interesse per l'implementazione del software che fin da questo momento possiamo dividere in due macro componenti le cui responsabilit\u00e0 devono essere:</p> <ol> <li>il setup della Smart Card (o chiave elettronica) in fase di     registrazione dell'ospite presso la struttura alberghiera.     All'interno della Smart Card sar\u00e0 memorizzato l'identificativo di un     documento di riconoscimento dell'ospite, sul database del sistema di     gestione dell'albergo saranno invece memorizzati i dati anagrafici     insieme ad altri dati necessari per associare la chiave elettronica     all'ospite e alla stanza a lui assegnata;</li> <li>la verifica che la chiave elettronica sia abilitata e associata     all'ospite e alla stanza a cui consentire l'accesso.</li> </ol>"},{"location":"guida/dettagli_mifare_classic_1k/","title":"Dettagli sulle carte MIFARE Classic 1K","text":"<p>MIFARE \u00e8 un marchio registrato di NXP Semiconductors. I prodotti MIFARE sono circuiti integrati ampiamente utilizzati per l'utilizzo in Smart Card senza contatto e molte altre applicazioni in tutto il mondo. La gamma MIFARE comprende circuiti integrati per la realizzazione di tessere contactless e lettori per la comunicazione con esse.</p> <p>Il nome MIFARE racchiude diversi tipi di Smart Card senza contatto, quella utilizzata in questo scenario rientra nel tipo Classic. Si tratta di schede di memoria a logica cablata che solo parzialmente sono conformi allo standard ISO/IEC 14443A (caratteristiche fisiche, potenza e interfaccia del segnale radio, inizializzazione e anticollisione), poich\u00e9 utilizzano un set di comandi proprietari invece del protocollo ISO/IEC 14443-4 di alto livello e non sono conformi al formato frame ISO/IEC 14443-3 e nelle comunicazioni crittografate usano un protocollo di sicurezza proprietario NXP (CRYPTO1) per l'autenticazione e la crittografia che \u00e8 stato rotto nel 2008.</p> <p>Dopo l'ultima frase immagino che vi stiate domandando: perch\u00e9 scrivere allora un articolo su questa Smart Card? </p> <p>La risposta \u00e8 abbastanza semplice. Questa \u00e8 una delle Smart Card a sola memoria pi\u00f9 diffuse e semplici da usare, e per il tipo di scenario qui presentato, la possibilit\u00e0 di scoprire \"facilmente\" la chiave di autenticazione \u00e8 secondario, inoltre, questo \u00e8 articolo prettamente didattico.</p> <p>La MIFARE Classic 1K dispone di 1024 byte di memoria (EEPROM) suddivisa in 16 segmenti; ogni settore \u00e8 protetto da due chiavi che vengono chiamate A e B. In tutti i tipi di carta, 16 byte a settore sono riservati alle chiavi e alle condizioni d\u2019accesso e non possono essere utilizzati per i dati dell\u2019utente; inoltre, i primi 16 byte contengono il numero di serie univoco e di sola lettura. In questo modo la memoria disponibile si riduce a 752 byte.</p> <p>Data l'altissima diffusione di questa tipologia di Smart Card e le versioni \"cinesi\" esistenti, dubito che non ci siano numeri di serie duplicati, visto anche che i byte dedicati alla memorizzazione del numero di serie sono quattro.</p> <p> Figura 4 - Struttura della memoria della Mifare Classic 1K (dal datasheet NXP MIFARE Classic EV1 1K https://www.nxp.com/docs/en/data-sheet/MF1S50YYX_V1.pdf)</p> <p>Prima di poter compiere operazioni di lettura o scrittura sui blocchi di memoria, \u00e8 necessario eseguire prima un'autenticazione tramite la chiave del settore del blocco. In genere tutte le chiavi (A e B) sono impostate su valore <code>FFFFFFFFFFFFh</code> in fase di produzione del chip (e in ogni caso la documentazione fornita al momento dell'acquisto fornisce indicazioni sulle chiavi di accesso e su come eseguire la modifica).</p> <p>La tabella mostrata in figura 5 rappresenta la mappa della memoria con in evidenza il range degli indirizzi per i Data Blocks e i Trailer Block per ogni settore. Questa mappa sar\u00e0 utile nel momento in cui dovremo leggere e scrivere sui data blocks.</p> <p> Figura 5 - Memory Map della MIFARE Classic 1K completa di range d'indirizzi dei blocchi</p> <p>Dopo questa sorvolata sulle caratteristiche principali della MIFARE Classic 1K che sono di nostro interesse per il nostro obiettivo, possiamo andare avanti ed esplorare il modo su come comunicare con la carta per le operazioni di autenticazione, lettura e scrittura.</p>"},{"location":"guida/implementare_software/","title":"Implementare il software","text":"<p>Adesso che il cosa \u00e8 chiaro, vediamo il come, rispondendo alle domande a seguire:</p> <ol> <li>Quale linguaggio usare per implementare lo scenario che abbiamo     descritto all'inizio dell'articolo? Python</li> <li>Esiste qualche libreria Python per la costruzione di applicazioni     basate su Smart Card?     Pyscard</li> <li>Quale tipo di database usare per la memorizzazione dei dati?     MongoDB     (NoSQL database)</li> <li>Esiste qualche libreria Python per operare con MongoDB?     PyMongo</li> <li>Esiste qualche libreria Python per interagire con l'interfaccia GPIO     del Raspberry     Pi? RPi.GPIO</li> </ol> <p>Da questa lista le cose da fare sono parecchie e lo spazio per vederle tutte nel dettaglio in questo articolo non c'\u00e8. Direi quindi di focalizzare la nostra attenzione sui componenti da realizzare rimanendo ad alto livello, senza scendere nello specifico del codice.</p> <p>Non vi allarmate! Il progetto \u00e8 gi\u00e0 stato sviluppato prima di scrivere questo articolo e disponibile sul mio repository GitHub Smart Card Contactless Raspberry Pi.</p> <p>Nota su MongoDB. \u00c8 necessario preparare un'istanza di MongoDB sul proprio Raspberry Pi affinch\u00e9 la soluzione funzioni nel modo corretto. Le scelte sono due: container docker o installazione classica direttamente sul sistema operativo. Personalmente ho scelto la strada di Docker (vedi 6. Requisiti Software), per cui, una volta installato Docker sul proprio Raspberry Pi OS, i passi per tirare su un'istanza MongoDB 4.4.12 sono quelli indicati a seguire.</p> <p><pre><code># 1. Docker pull e run MongoDB 4.4.12\ndocker pull mongo:4.4.12\ndocker run -d -p 27017-27019:27017-27019 --name mongodb mongo:4.4.12\n\n# 2. Verifica che l'istanza sia su e accesso alla console bash (task opzionale)\ndocker exec -it mongodb bash\n\n# 3. Avvio della console MongoDB (task opzionale)\nroot@0d21da235b0d:/# mongo\n</code></pre> Console 1 - Pull dell'immagine MongoDB 4.4.12 e run del container</p> <p>Nel caso in cui preferiate perseguire la seconda strada, il blog di MongoDB riporta la procedura completa sull'articolo Install &amp; Configure MongoDB on the Raspberry Pi.</p>"},{"location":"guida/introduzione/","title":"Introduzione","text":"<p>Le Smart Card fanno parte ormai da tempo del nostro quotidiano:  dalla SIM (Subscriber Identity Module) del cellulare, alla carta di credito, come sistema di fidelizzazione, per accedere ai locali e come mezzo per fruire dei servizi della pubblica amministrazione.</p> <p>Integrare sistemi di autenticazione basati su Smart Card nei propri sistemi e applicazioni, credo che possa essere un'attivit\u00e0 molto interessante per chi programma e l'aspetto a mio avviso pi\u00f9 coinvolgente \u00e8 la vicinanza con quelli che amo definire bonariam\u00e9nte \"pezzi di ferro\".</p> <p>Quasi due anni fa ho scritto l'articolo Raspberry Pi \u2013 Un esempio di applicazione della TS-CNS,  dove mostravo come poter creare un sistema di accesso utilizzando la propria TS-CNS; in questo articolo vedremo invece come mettere insieme: Raspberry Pi, modulo da quattro rel\u00e8, lettore di Smart Card e MIFARE Classic 1K contactless Smart Card per poi armonizzare il tutto, sviluppando il software necessario allo scopo di realizzare un sistema di accesso.</p> <p>Per lo sviluppo del progetto \u00e8 necessario toccare un numero considerevole di argomenti e cercher\u00f2 di trattare i principali con il giusto livello di profondit\u00e0, in caso contrario l\u2019articolo assumerebbe delle dimensioni notevoli. Mi impegner\u00f2 a lasciare tutti i riferimenti utili per ogni vostro approfondimento.</p> <p>A questo punto direi d\u2019iniziare; mettetevi comodi e munitevi della giusta concentrazione perch\u00e9 la lettura di questo articolo sar\u00e0 abbastanza impegnativa ma spero interessante.</p>"},{"location":"guida/misteriosi_pacchetti_apdu/","title":"I misteriosi pacchetti APDU","text":"<p>La comunicazione delle informazioni tra la carta e il lettore \u00e8 resa possibile grazie allo scambio di pacchetti detti APDU (Application Protocol Data Unit); essi rappresentano l\u2019unit\u00e0 di comunicazione tra il lettore e la carta e la loro struttura \u00e8 ben definita da ISO/IEC 7816-4 Organization, security and commands for interchange.</p> <p>Esistono due tipi di APDU: quelli di comando e quelli di risposta. I primi richiedono un set di attributi attraverso cui il lettore \u00e8 in grado di sapere quali operazioni compiere e quali dati inviare, i secondi contengono il risultato dell\u2019operazione richiesta con in coda l'esito dell'operazione.</p> <p>La tabella di figura 6 mostra la struttura dei comandi APDU che attraverso il lettore di Smart Card possiamo inviare alla carta MIFARE.</p> <p> Figura 6 - Struttura dei comandi APDU</p> <p>La tabella di figura 7 mostra un esempio di comando APDU per ottenere l'UID della MIFARE Classic 1K, la cui lunghezza \u00e8 pari a 4 byte (vedi attributo Le). A fronte dei comandi inviati, riceviamo sempre una risposta che ha la struttura indicata dalla tabella di figura 8.</p> <p> Figura 7 - Comando per ottenere l'UID della Smart Card MIFARE Classic 1K</p> <p> Figura 8 - Struttura di risposta APDU</p> <p>La tabella di figura 9 mostra la risposta ottenuta a fronte del comando APDU per richiedere l'UID (vedi figura 7) la cui lunghezza dell'UID \u00e8 pari a 4 byte pi\u00f9 2 byte che segnalano l\u2019esito del comando. L\u2019UID \u00e8 restituito con il byte meno significativo (LSB) a sinistra e quello pi\u00f9 significativo (MSB) a destra (quindi usa il sistema little-endian).</p> <p> Figura 9 - Risposta del comando APDU per ottenere l'UID della MIFARE Classic 1K</p> <p>Confrontando i valori di SW1 e SW2 (Status Word) con quelli riportati dalla tabella mostrata in figura 10 \u00e8 possibile evincere se l'esecuzione del comando \u00e8 andato a buon fine.</p> <p>Attenzione. I valori di SW1 e SW2 fanno riferimento al comando per ottenere l'UID della carta; questi valori potrebbero essere diversi per altre classi di comando, in particolare nei casi di errore.</p> <p> Figura 10 - Codici di risposta APDU comando UID</p> <p>Per maggiori dettagli sui comandi ed eventuali estensioni, consiglio sempre di consultare il datasheet della MIFARE Classic 1K. I comandi APDU di nostro interesse per implementare lo scenario descritto nella parte introduttiva dell'articolo, sono:</p> <ul> <li>comando per ottenere l'UID della carta;</li> <li>comando per leggere i dati da un determinato settore e blocco;</li> <li>comando per scrivere dati su un determinato settore e blocco della carta.</li> </ul>"},{"location":"guida/progettare_software/","title":"Progettare il software","text":"<p>\u00c8 arrivato il momento di saltare dall'hardware al software cercando di delineare ci\u00f2 che dovremo implementare con l'obiettivo di soddisfare i requisiti espressi in forma di diagrammi BPMN (vedi figura 2 e figura 3). Ricordo che solo quanto espresso dai Service Task deve essere realizzato in forma di software.</p> <p>Cerchiamo di identificare il cosa dovr\u00e0 essere soddisfatto dal punto di vista funzionale per poi passare al come gli aspetti funzionali dovranno essere implementati. La tabella mostrata in figura 16 (trasposizione di una classica Mind Map), descrive gli aspetti funzionali che il software che andremo a realizzare deve implementare.</p> <p> Figura 16 - Mind Map sugli aspetti funzionali che il software dovr\u00e0 implementare</p> <p>Il software deve prevedere due entry point, ed esattamente quelli indicati all'interno della tabella di figura 16, le cui responsabilit\u00e0 devo essere:</p> <ul> <li>Setup Smart Card: entry point la cui principale responsabilit\u00e0 \u00e8   quella di \"formattare\" la Smart Card (o chiave elettronica) con i dati   personali dell'ospite e in questo caso il numero del documento   d'identit\u00e0, inoltre, creare l'associazione tra chiave elettronica,   ospite e stanza a lui assegnata. Una volta eseguiti i task di questo   entry point (vedi figura 16), la Smart Card potr\u00e0 essere consegnata   all'ospite.</li> <li>Gestione Accesso Porte entry point la cui principale   responsabilit\u00e0 \u00e8 quella di garantire l'accesso (apertura della porta   della stanza) solo a coloro che hanno in possesso una Smart Card   valida, aggiornando i dati di accesso sul database. La Mind Map di   figura 16 mostra i singoli task che devono essere eseguiti da questo   specifico entry point.</li> </ul> <p>Pi\u00f9 volte \u00e8 stato fatto riferimento all'esistenza di un database, bene, adesso cerchiamo di capire quali sono i dati da esso trattati e le responsabilit\u00e0 dei due entry point in merito al trattamento di questi dati. La tabella di figura 17 mostra la struttura dati del documento che descrive l'associazione ospite, Smart Card e stanza assegnata e traccia i dati degli eventi d'inizializzazione e accesso.</p> <p> Figura 17 - Struttura dati che descrive l'associazione ospite, smart card e stanza assegnata e traccia i dati degli eventi d'inizializzazione e accesso</p> <p>La tabella mostra un'informazione importante per ogni attributo del documento, ovvero, lo scope, quindi l'entry point, con evidenza del diritto di accesso: (r -read) lettura o (w - write) scrittura.</p>"},{"location":"guida/pyscard/","title":"Cos\u2019\u00e8 Pyscard","text":"<p>Pyscard, Python Smart Card library, \u00e8 un modulo Python che aggiunge il supporto per le Smart Card facilitando la costruzione di applicazioni che hanno la necessit\u00e0 di utilizzare la tecnologia delle Smart Card.</p> <p>Pyscard supporta la piattaforma Microsoft Windows utilizzando i componenti Microsoft Smart Card Base, Linux e macOS utilizzando PCSC-lite. Il diagramma di figura 18 mostra l'architettura Pyscard (box in verde). Il modulo smartcard.scard \u00e8 il wrapper di WinSCard API (smart card base components). Il modulo smartcard \u00e8 un vero e proprio framework costruito su PC/SC API.</p> <p> Figura 18 - Architettura di Pyscard</p> <p>Pyscard sar\u00e0 di aiuto per:</p> <ol> <li>Eseguire la connessione al lettore di Smart Card e alla MIFARE     Classic 1K</li> <li>Filtrare le connessioni alle sole MIFARE Classic 1K tramite l'ATR</li> <li>Inviare i comandi APDU</li> <li>Ricevere le risposte ai comandi APDU</li> <li>Intercettare gli eventi di aggiunta e rimozione Smart Card dal     lettore</li> </ol>"},{"location":"guida/requisiti_hardware/","title":"Requisiti Hardware","text":"<p>Realizzare lo scenario descritto richiede il recupero di una serie di \"pezzi di ferro\".</p> <ol> <li>Raspberry Pi 4 Model B 8GByte RAM</li> <li>MicroSD Card (min 8GByte)</li> <li>Elegoo 4 Channel DC 5V     Modulo Relay</li> <li>Jumper     Wire Cable Cavo F2F female to female</li> <li>Bit4id miniLector CIE</li> <li>Mifare Classic 1K</li> <li>Mifare Classic 1K RFID     Tag (opzionale)</li> </ol> <p>Per quanto riguarda il Raspberry Pi \u00e8 possibile optare per la versione con 4GByte di RAM ma \u00e8 importante installare come sistema operativo l'ultima versione di Raspberry Pi OS affinch\u00e9 sia supportato il lettore di Smart Card Bit4id miniLector CIE e questo grazie alla versione 1.4.34-1 della libreria libccid (check via <code>apt info libccid</code>).</p> <p> Figura 13 - Dettaglio del driver libccid necessario per interoperabilit\u00e0 tra Sistema Operativo e lettore di Smart Card</p> <p>Nel caso in cui abbiate gi\u00e0 un lettore di Smart Card o vogliate acquistarne un diverso modello, consiglio di consultare la lista dei lettori di Smart Card supportati dal driver libccid.</p>"},{"location":"guida/requisiti_software/","title":"Requisiti Software","text":"<p>Cos\u00ec come abbiamo bisogno dell'hardware, \u00e8 necessario che siano soddisfatti una serie di requisiti software, quali:</p> <ol> <li>Raspberry Pi OS (64bit)</li> <li>Python 3.9.x (distribuito e installato di default     con Raspberry Pi OS)</li> <li>Docker 20.10.12</li> <li>Development Tools (make, gcc) (install or update     via <code>sudo apt install build-essential</code>)</li> </ol> <p>Per questo genere di scenari non \u00e8 assolutamente necessario provvedere all'installazione del sistema operativo in versione Desktop, consiglio pertanto di preparare e usare l'immagine di Raspberry Pi OS Lite (64bit). Per coloro che avessero bisogno di una guida su come installare questo sistema operativo, consiglio di seguire la guida ufficiale Installing the Operating System.</p> <p>L'installazione di Docker potrebbe essere anche opzionale; personalmente preferisco installare il database in forma di container. Pi\u00f9 in avanti vedremo quale database ho scelto per questa soluzione.</p> <p>Per approfondimenti sul tema Docker, consiglio la lettura del libro Docker: Sviluppare e rilasciare software tramite container di Serena Sensini e la visione delle Pillole di Docker sul canale YouTube di Mauro Cicolella.</p>"},{"location":"guida/risorse/","title":"Risorse","text":"<p>Come di consueto lascio una serie di risorse che ritengo utili ai fini dell\u2019approfondimento degli argomenti trattati nel corso di questo articolo.</p> <ul> <li>Attuatori per maker   \u2013 https://amzn.to/3slHmE9</li> <li>Raspberry Pi. La guida completa   \u2013 https://amzn.to/2RpYZWh</li> <li>Docker: Sviluppare e rilasciare software tramite container   \u2013 https://amzn.to/3tiyO1W   di Serena Sensini</li> <li>Valutiamo se continuare a usare Docker o passare a Podman   \u2013 https://www.theredcode.it/podman/what-is-podman/</li> <li>Pillole di Docker   \u2013 https://www.youtube.com/watch?v=wAyUdtQF05w di Mauro Cicolella</li> <li>Raspberry PI GPIO \u2013 Tutti i segreti del pinout \u2013 https://www.moreware.org/wp/blog/2021/04/09/raspberry-pi-gpio-tutti-i-segreti-del-pinout/</li> <li>Smart cards \u2013 A short illustrated guide ( Feb. 2022) - https://www.thalesgroup.com/en/markets/digital-identity-and-security/technology/smart-cards-basics</li> <li>Hacking Mifare Classic Cards - https://www.blackhat.com/docs/sp-14/materials/arsenal/sp-14-Almeida-Hacking-MIFARE-Classic-Cards-Slides.pdf</li> <li>How to Crack Mifare Classic Cards -   https://firefart.at/post/how-to-crack-mifare-classic-cards/</li> <li>A Practical Attack on the MIFARE Classic -   https://arxiv.org/pdf/0803.2285.pdf</li> <li>ACR122U Application Programming Interface - https://www.acs.com.hk/download-manual/419/API-ACR122U-2.04.pdf</li> </ul>"},{"location":"guida/schema_elettrico/","title":"Schema elettrico della soluzione","text":"<p>Una volta ottenuto l'hardware (indicato in precedenza), possiamo procedere con il collegamento del modulo dei quattro rel\u00e8 all'interfaccia GPIO con l'ausilio dei jumper femmina-femmina.</p> <p>La figura 14 mostra lo schema elettrico di collegamento tra il modulo a quattro rel\u00e8 e il Raspberry Pi. Ricordo che il lettore di Smart Card \u00e8 collegato via USB al Raspberry Pi. Utilizzando i jumper e seguendo lo schema, il risultato sar\u00e0 assicurato. \u00c8 preferibile eseguire l'operazione di collegamento lasciando il proprio Raspberry Pi spento e scollegato dalla fonte di alimentazione.</p> <p> Figura 14 - Schema elettrico di collegamento tra il Raspberry Pi e il modulo da quattro rel\u00e8</p> <p>Per ogni dubbio sulla disposizione dei pin del connettore J8 del Raspberry, consultare l'output del comando <code>pinout</code> (vedi figura 15) prima di procedere con l'operazione di collegamento, oppure, puntate il vostro browser su pinout.xyz.</p> <p> Figura 15 - Output del comando pinout, utile per verificare la piedinatura del GPIO e altre informazione sul layout hardware e componenti</p>"},{"location":"guida/struttura_progetto/","title":"Struttura del progetto software","text":"<p>Adesso che abbiamo visto dalla superficie cos'\u00e8 Pyscard e per cosa sar\u00e0 utile, cerchiamo di disegnare la struttura del nostro progetto che implementer\u00e0 lo scenario introdotto a inizio articolo.</p> <p>Il diagramma (in notazione UML) di figura 19 mostra package, component e classi utilizzati per l'implementazione dello scenario che abbiamo descritto a inizio articolo. Gli elementi del diagramma del nostro progetto sono quelli evidenziati con il colore giallo ocra e in particolare:</p> <ul> <li>Classi<ul> <li>ManageRelay (manage_relay.py).   Classe che gestisce attraverso l'interfaccia GPIO l'attivazione e   disattivazione dei quattro rel\u00e8, nonch\u00e9 l'inizializzazione della   stessa interfaccia GPIO.</li> <li>SmartCardAccessCrud   (smart_card_access_crud.py). Classe che gestisce le operazioni CRUD   sul database NoSQL MongoDB.</li> <li>MifareClassicInterface   (mifare_interface.py). Classe che gestisce la comunicazione con il   lettore di Smart Card e di conseguenza d'interagire con la Smart   Card connessa. Le operazioni gestite sono: autenticazione, lettura   ATR, lettura UID, lettura dalla memoria della carta e scrittura   sulla memoria della carta.</li> </ul> </li> <li>Component<ul> <li>Setup Smart Card   (setup_smart_card.py). Script Python che rapprensentata l'entry   point responsabile del setup della Smart Card e memorizzazione dei   dati anagrafici dell'ospite sul database MongoDB. Questo script deve   ricevere in input i parametri necessari per eseguire il setup della   Smart Card.</li> <li>Access via Smart Card   (access_via_smart_card.py). Script Python che rappresenta l'entry   point responsabile di governare l'apertura delle porte (attraverso   l'attivazione dei rel\u00e8) sulla base della validazione dei dati   estratti dalla Smart Card. Questo script deve ricevere in input la   chiave di autenticazione della Smart Card.</li> </ul> </li> </ul> <p> Figura 19 - Package/Component/Class diagram del progetto Smart Card Contactless Raspberry Pi</p> <p>Il package smartcard (in verde) fa parte di Pyscard, e i componenti all'interno sono utilizzati per sfruttare il monitoraggio delle Smart Card. Utilizzando l'interfaccia CardObserver siamo in grado di poter sapere quando la Smart Card viene aggiunta (appoggiata sul lettore) o rimossa (dal raggio di azione del segnale RF).</p> <p>Il sequence diagram di figura 20 descrive lo scenario del setup della Smart Card (vedi Figura 2 - Processo semplificato di accoglienza dell'ospite in hotel), mostrando le azioni principali e gli eventuali flussi alternativi. Sempre da questo diagramma possiamo vedere le relazioni che intercorrono, in termini di messaggi, tra i vari attori, quest'ultimi sono stati descritti in precedenza e mostrati nel diagramma di figura 19.</p> <p>Le azioni decisamente pi\u00f9 importanti sono quelle che riguardano l'invio dei comandi APDU, che riassumendo sono:</p> <ol> <li>Load Authentication Key sulla memoria     volatile</li> <li>Autenticazione per accedere al primo     blocco del settore uno della MIFARE Classic 1K</li> <li>Richiesta UID</li> <li>Lettura dell'eventuale precedente     documentId (numero identificativo del documento di riconoscimento)</li> <li>Salvataggio del documentId</li> </ol> <p>I link della precedente lista riportano direttamente sul metodo specifico della classe Mifare Classic Interface all'interno del quale \u00e8 specificato il contenuto dell'APDU inviata.</p> <p> Figura 20 - Diagramma di sequenza dell'entry point Setup Smart Card</p> <p>Nella fase di setup della Smart Card, prima di inserire i dati anagrafici dell'ospite sul database, viene eseguita la query utilizzando il filtro <code>{\"smartCardId\": \"f{uid}\", \"documentId\": f\"{identification_number}\"}</code> , in modo che sia possibile verificare che non esista gi\u00e0 un documento con l'associazione smartCardId e documentId (fare riferimento allo step 33 del sequence diagram di figura 20).</p> <p>Il sequence diagram di figura 21 descrive lo scenario di Accesso alla stanza tramite Smart Card (vedi Figura 3 - Processo di accesso alla stanza), mostrando le azioni principali e gli eventuali flussi alternativi. Sempre da questo diagramma possiamo vedere le relazioni che intercorrono, in termini di messaggi, tra i vari attori, quest'ultimi sono stati descritti in precedenza e mostrati nel diagramma di figura 19.</p> <p>In questo diagramma, tra gli attori in gioco abbiamo anche il componente Card Monitor di Pyscard, che abbiamo utilizzato per aggiungere la nostra interfaccia Mifare Classic Interface come observable, in questo modo il Card Monitor richiamer\u00e0 il metodo update(self, observable, actions) nel momento in cui si verificheranno gli eventi di aggiunta o rimozione della Smart Card. Il metodo update implementa quando descritto in Figura 16 - Mind Map sugli aspetti funzionali che il software dovr\u00e0 implementare, di cui le azioni sono evidenti sul sequence diagram a seguire.</p> <p> Figura 21 - Diagramma di sequenza per l'entry point Access via Smart Card</p> <p>I dati sono estratti dal database MongoDB utilizzando il filtro <code>{\"smartCardId\": f\"{uid}\", \"documentId\":f{identification_number}\", \"smartCardEnabled\": \"true\"}</code>, nel caso non ci siano documenti che rispettino questo filtro, il sistema negher\u00e0 l'accesso, alternativamente, sar\u00e0 aggiornato il documento su MongDB e attivato il rel\u00e8 corrispondente al numero della stanza associato all'ospite (fare riferimento allo step 1.7 del sequence diagram di figura 21).</p> <p>Molto bene! Una volta descritti i sequence diagram dei nostri due scenari, direi che potremmo passare all'azione, ovvero, eseguire il deploy dell'applicazione sul Raspberry Pi 4.</p>"}]}